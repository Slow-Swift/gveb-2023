{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"api = getApi(\"0.0.227\")","pinCode":false,"dname":"107a3865-b17f-4b0c-8c03-563ee0ff0c92","codeMode":"javascript2","hide":true}}},{"type":"codeTool","data":{"codeData":{"value":"data = Object() ","pinCode":false,"dname":"f0e75b1b-89f9-4a5c-98e8-1f9d316c389e","codeMode":"javascript2","hide":true}}},{"type":"codeTool","data":{"codeData":{"value":"function lerp_nodes(node1, node2, t) {\n  let lat1 = node1.properties['latitude']\n  let lat2 = node2.properties['latitude']\n  let lng1 = node1.properties['longitude']\n  let lng2 = node2.properties['longitude']\n  \n  let agent_lat = lat1 + (lat2 - lat1) * t;\n  let agent_lng = lng1 + (lng2 - lng1) * t;\n  return [agent_lat, agent_lng]\n}","pinCode":false,"dname":"c98b4a69-6b89-4e7b-a7d8-5a27f45f65bd","codeMode":"javascript2","hide":true}}},{"type":"codeTool","data":{"codeData":{"value":"viewof map1 = {\n  const container = yield htl.html`<div style=\"height: 500px;\">`;\n  const vancouver_pos = [49.25, -123]; \n  const map = L.map(container).setView(vancouver_pos, 12);\n  L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n    attribution: \"Â© <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors\"\n  }).addTo(map);\n  \n  data.map = map; \n}","pinCode":false,"dname":"d21f0174-87bb-4efd-bdc6-59dd7414effc","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"function get_neighbor_and_length(graph, junction) {\n  let neighbors = graph.findNeighbors(junction.id).filter((neighbor) => neighbor.neighbor.category = \"Junction\");\n  if (neighbors.length == 0) return [junction, 0];\n  \n  let index = Math.floor(Math.random() * neighbors.length);\n  let junction_2 = neighbors[index].neighbor;\n  let length = neighbors[index].connectedEdge.properties.length_metres;\n  return [junction_2, length]\n}","pinCode":false,"dname":"e9606e09-9042-4981-ba39-e0f71efac045","codeMode":"javascript2","hide":true}}},{"type":"codeTool","data":{"codeData":{"value":"Grove.AsyncButton({\n  label: \"Run Agent\", \n  onClick: pathWalker\n})","pinCode":false,"dname":"2892e08d-bacf-45ac-8714-ae914a72cc17","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"async function randomWalker () {\n  data.running = true\n  if (data.agent) {\n  \tdata.agent.removeFrom(data.map);\n    data.j1.removeFrom(data.map);\n    data.j2.removeFrom(data.map);\n  }\n  \n  let graph = api.getLayoutGraph();\n  \n  let junctions = graph.getVisibleNodes().filter(api.nodesByCategory(\"Junction\"));\n  let index = Math.floor(Math.random() * junctions.length);\n  let junction_1 = junctions[index];\n  let [junction_2, length] = get_neighbor_and_length(graph, junction_1);\n  \n  let begin_time = performance.now() / 1000;\n  let time = begin_time;\n  let meters_per_second = 30;\n  \n  let agent_pos = lerp_nodes(junction_1, junction_2, 0);\n  let agent = L.marker(agent_pos).addTo(data.map);\n  data.agent = agent;\n \n  data.j1 = L.circleMarker([junction_1.properties.latitude, junction_1.properties.longitude]).addTo(data.map);\n  data.j2 = L.circleMarker([junction_2.properties.latitude, junction_2.properties.longitude]).addTo(data.map);\n  \n  while (data.running) {\n    time = performance.now() / 1000 - begin_time;\n    \n    if (time * meters_per_second / length >= 1) {\n      begin_time += length / meters_per_second;\n      time = performance.now() / 1000 - begin_time;\n      junction_1 = junction_2;\n      [junction_2, length] = get_neighbor_and_length(graph, junction_1);\n      \n      data.j1.setLatLng([junction_1.properties.latitude, junction_1.properties.longitude]);\n      data.j2.setLatLng([junction_2.properties.latitude, junction_2.properties.longitude]);\n    }\n    \n    agent_pos = lerp_nodes(junction_1, junction_2, time * meters_per_second / length);\n    agent.setLatLng(agent_pos);\n    await api.sleep(20);\n  }\n}","pinCode":false,"dname":"f26eece0-f5f0-4e7a-b181-8863269f831c","codeMode":"javascript2","hide":true}}},{"type":"codeTool","data":{"codeData":{"value":"async function pathWalker () {\n  data.running = true\n  if (data.agent) {\n  \tdata.agent.removeFrom(data.map);\n    data.j1.removeFrom(data.map);\n    data.j2.removeFrom(data.map);\n  }\n  \n  let graph = api.getLayoutGraph();\n  \n  let junctions = graph.getVisibleNodes().filter(api.nodesByCategory(\"Junction\"));\n  if (junctions.length == 0) return;\n  \n  let start_junction = junctions[Math.floor(Math.random() * junctions.length)];\n  let end_junction = junctions[Math.floor(Math.random() * junctions.length)];\n  \n  data.j1 = L.circleMarker([start_junction.properties.latitude, start_junction.properties.longitude]).addTo(data.map);\n  data.j2 = L.circleMarker([end_junction.properties.latitude, end_junction.properties.longitude]).addTo(data.map);\n  \n  console.log(\"Running dijkstra\")\n  let paths = api.dijkstra(graph, {sourceId: start_junction.id, targetId: end_junction.id, weightProperty: \"length_meters\"});\n  console.log(\"Dijkstra finished\")\n  if (paths.length == 0 || paths[0].length < 2) return;\n  \n  let path = paths[0];\n  let path_index = 0;\n  \n  let junction_1 = graph.getNode(path[path_index].nodeId);\n  let junction_2 = graph.getNode(path[path_index + 1].nodeId);\n  let length = graph.getEdge(path[path_index].edgeId).properties.length_metres;\n  \n  let begin_time = performance.now() / 1000;\n  let time = begin_time;\n  let meters_per_second = 30;\n  \n  let agent_pos = lerp_nodes(junction_1, junction_2, 0);\n  let agent = L.marker(agent_pos).addTo(data.map);\n  data.agent = agent;\n \n  \n  \n  while (data.running) {\n    time = performance.now() / 1000 - begin_time;\n    \n    if (time * meters_per_second / length >= 1) {\n      begin_time += length / meters_per_second;\n      time = performance.now() / 1000 - begin_time;\n      path_index += 1;\n      if (path_index >= path.length - 1) {\n        data.running = false;\n        break;\n      }\n      junction_1 = junction_2;\n      junction_2 = graph.getNode(path[path_index + 1].nodeId);\n      length = graph.getEdge(path[path_index].edgeId).properties.length_metres;\n      \n      //data.j1.setLatLng([junction_1.properties.latitude, junction_1.properties.longitude]);\n      //data.j2.setLatLng([junction_2.properties.latitude, junction_2.properties.longitude]);\n    }\n    \n    agent_pos = lerp_nodes(junction_1, junction_2, time * meters_per_second / length);\n    agent.setLatLng(agent_pos);\n    await api.sleep(20);\n  }\n}","pinCode":false,"dname":"8b7f9e71-1f1d-43e9-9510-96719272e44f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Grove.Button({\n  label: \"Stop Agent\",\n  onClick: () => {\n    data.running = false;\n  }\n})","pinCode":false,"dname":"0a76fe49-6e70-44b7-9e2f-69b7e6876dea","codeMode":"javascript2"}}}],"version":"2.19.1"}